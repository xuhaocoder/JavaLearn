#### OS设备与程序交互

操作系统的接口(Interface):系统调用(system call) 异常(exception) 中断(interrupt)
外设：中断IO  ，应用程序：系统调用，异常
系统调用:APP(来源) 主动向OS发出服务请求
异常：APP(来源) 非法指令或者其他错的处理状态（内存出错）
中断：来源于外设 ，来自不同的硬件设备的计时器和网络的中断

- **中断、异常、系统调用的区别**

  1. 来源
     中断来自外设(键盘、鼠标等)
     异常：app的意外
     系统调用：app请求OS提供服务，是App提出有明确的指令和相应的参数
  2. 处理时间
     中断：一般是异步事件（中断事件不可预测）
     异常：同步（出发点固定）
     系统调用：同步或异步
  3. 响应状态
     中断：打断当前app的正常执行，但是app并有感觉到中断产生
     异常：后果严重时，会杀死app，或者重新执行产生异常的指令
     系统调用：等待服务完成后继续执行，不会重复执行系统调用指令

- **中断的处理过程**
  硬件：设置中断标记[CPU初始化]

  - 将内部、外部事件设置中断标记
  - 中断事件的ID

  软件：

  - 保存当前处理状态
  - 中断服务程序处理
  - 清除中断标记
  - 恢复之前保存的处理状态

- **异常的处理过程：异常编号**

  - 保存现场
  - 异常处理
    - 杀死产生了异常的程序
    - 重新执行异常指令
  - 恢复现场
  - 系统调用
    操作系统服务的编程接口，通常由C/C++编写，程序通常是访问高层API而不是直接系统调用

- **系统调用的实现**

  - app会直接或者间接通过库（lib）来访问系统调用的接口，一旦访问，会触发内核态和用户态的切换
  - 用户态：app执行过程中，CPU处于一个特权级的状态，特权特别低，不能直接访问某些特殊的机器指令和直接访问IO
  - 内核态：OS运行过程中CPU处于的一个状态，这个状态下OS会执行任意指令，安全性得到保障

- **函数调用和系统调用的区别**
  app发出函数调用，其实是一个栈空间完成的参数的传递和返回
  系统调用的过程中，app和OS有各自的堆栈，切换堆栈和特权级转换会带来很大的开销

- **开销**

  - 内核堆栈的开销
  - 验证参数的开销
  - 内核态映射到用户态的开销
    OS处理完某些数据后，会把这些数据从内核态拷贝到用户态，这个过程会有新的开销
  - 内核态独立地址空间的开销

  